<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lost In The Woods - Detailed Solution Explanation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            text-align: center;
        }
        h2 {
            color: #2980b9;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
        }
        .section {
            margin-bottom: 30px;
        }
        pre {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            overflow-x: auto;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
        }
        .formula {
            background-color: #fff9e6;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #f39c12;
            font-style: italic;
        }
        .checkmark {
            color: #27ae60;
            font-weight: bold;
        }
        ul, ol {
            margin-left: 20px;
        }
        li {
            margin: 8px 0;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LOST IN THE WOODS - DETAILED SOLUTION EXPLANATION</h1>

        <div class="section">
            <h2>PROBLEM OVERVIEW</h2>
            <p>Given a graph representing clearings in a woods connected by paths, we need to find the expected time for a person to reach the exit (node N-1) starting from node 0, where at each clearing they choose a uniformly random adjacent clearing to move to next (including potentially going back).</p>
            <p>This is a classic "expected hitting time" problem in the theory of random walks on graphs, also known as a Markov chain problem.</p>
        </div>

        <div class="section">
            <h2>MATHEMATICAL FORMULATION</h2>
            <p>Let <code>E[i]</code> denote the expected number of minutes to reach the exit starting from clearing i.</p>
            
            <div class="formula">
                <strong>Base Case:</strong><br>
                E[N-1] = 0&nbsp;&nbsp;&nbsp;&nbsp;(already at the exit, so 0 time needed)
            </div>

            <div class="formula">
                <strong>Recursive Case (for any clearing i ≠ N-1):</strong><br>
                E[i] = 1 + (1/deg(i)) * Σ(E[j] for all neighbors j of i)<br><br>
                Where deg(i) is the degree of node i (number of adjacent clearings).
            </div>

            <p><strong>Explanation of the recursive formula:</strong></p>
            <ul>
                <li>The "+1" represents the 1 minute spent traveling to the next clearing</li>
                <li>The person chooses each of deg(i) neighbors with probability 1/deg(i)</li>
                <li>So the expected time is 1 minute plus the weighted average of E[j] over all neighbors j</li>
            </ul>
        </div>

        <div class="section">
            <h2>WHY THIS FORMS A LINEAR SYSTEM</h2>
            <p>Rearranging the recursive formula for clearing i (i ≠ N-1):</p>
            <pre>E[i] = 1 + (1/deg(i)) * Σ(E[j] for all neighbors j)

E[i] - (1/deg(i)) * Σ(E[j]) = 1

deg(i) * E[i] - Σ(E[j]) = deg(i)</pre>

            <p>For each non-exit clearing i, this gives us one linear equation. Since E[N-1]=0, we have N-1 unknowns (E[0], E[1], ..., E[N-2]) and N-1 equations.</p>
            
            <div class="formula">
                This can be written in matrix form: <strong>A * E = b</strong>
            </div>

            <p>Where:</p>
            <ul>
                <li><strong>A</strong> is an (N-1) × (N-1) coefficient matrix</li>
                <li><strong>E</strong> is the vector of unknowns [E[0], E[1], ..., E[N-2]]</li>
                <li><strong>b</strong> is a constant vector</li>
            </ul>
        </div>

        <div class="section">
            <h2>DETAILED ALGORITHM STEPS</h2>

            <h3>STEP 1: INPUT PARSING</h3>
            <ol type="a">
                <li>Read N (number of clearings) and M (number of paths)</li>
                <li>Initialize an adjacency list representation of the graph</li>
                <li>For each of M edges, read clearings K and L, and add:
                    <ul>
                        <li>L to the neighbor list of K</li>
                        <li>K to the neighbor list of L</li>
                        <li>(since paths are bidirectional)</li>
                    </ul>
                </li>
            </ol>

            <h3>STEP 2: SET UP THE LINEAR SYSTEM</h3>
            <ol type="a">
                <li>Determine the number of unknowns: n_unknowns = N - 1<br>
                    (we exclude the exit node N-1 since E[N-1] = 0)</li>
                <li>Create a zero matrix A of size (N-1) × (N-1)</li>
                <li>Create a zero vector b of length N-1</li>
                <li>For each non-exit clearing i (i = 0, 1, ..., N-2):
                    <ul>
                        <li>Calculate deg(i) = number of neighbors of clearing i</li>
                        <li>Set A[i][i] = 1 (coefficient of E[i] in equation i)</li>
                        <li>For each neighbor j of clearing i:
                            <ul>
                                <li>If j ≠ N-1 (neighbor is not the exit): Set A[i][j] = -1/deg(i)</li>
                                <li>If j = N-1 (neighbor is the exit): Contributes 0 since E[N-1] = 0, so we add nothing</li>
                            </ul>
                        </li>
                        <li>Set b[i] = 1 (the constant term on the right-hand side)</li>
                    </ul>
                </li>
            </ol>

            <h3>STEP 3: SOLVE THE LINEAR SYSTEM</h3>
            <ol type="a">
                <li>Use numpy's linear algebra solver: E = np.linalg.solve(A, b)</li>
                <li>This solves the equation A * E = b for the vector E</li>
                <li>The solver uses efficient numerical methods (typically LU decomposition)</li>
            </ol>

            <h3>STEP 4: OUTPUT THE RESULT</h3>
            <ol type="a">
                <li>The answer is E[0] (expected time starting from clearing 0)</li>
                <li>Format and print with 6 decimal places</li>
            </ol>
        </div>

        <div class="section">
            <h2>EXAMPLE WALKTHROUGH: SAMPLE INPUT 1</h2>
            
            <h3>Input:</h3>
            <pre>3 3
0 1
1 2
0 2</pre>

            <h3>Graph structure:</h3>
            <pre>Node 0 connects to: [1, 2]
Node 1 connects to: [0, 2]
Node 2 (EXIT) connects to: [1, 0]</pre>

            <p><strong>Unknowns:</strong> E[0], E[1]&nbsp;&nbsp;(since E[2] = 0)</p>

            <h3>Equations:</h3>
            <pre>For node 0 (degree = 2):
  E[0] = 1 + (1/2)*E[1] + (1/2)*E[2]
  E[0] = 1 + (1/2)*E[1] + 0
  E[0] - (1/2)*E[1] = 1

For node 1 (degree = 2):
  E[1] = 1 + (1/2)*E[0] + (1/2)*E[2]
  E[1] = 1 + (1/2)*E[0] + 0
  E[1] - (1/2)*E[0] = 1</pre>

            <h3>Matrix form:</h3>
            <pre>[ 1    -1/2 ] [ E[0] ]   [ 1 ]
[ -1/2   1  ] [ E[1] ] = [ 1 ]</pre>

            <h3>Solving:</h3>
            <pre>From equation 1: E[0] = 1 + (1/2)*E[1]
Substitute into equation 2: E[1] - (1/2)*(1 + (1/2)*E[1]) = 1
                             E[1] - 1/2 - (1/4)*E[1] = 1
                             (3/4)*E[1] = 3/2
                             E[1] = 2

Back-substitute: E[0] = 1 + (1/2)*2 = 2</pre>

            <div class="highlight">
                <strong>Answer: 2.000000 <span class="checkmark">✓</span></strong>
            </div>
        </div>

        <div class="section">
            <h2>CORRECTNESS AND CONVERGENCE</h2>
            <p>The system of equations has a unique solution if and only if the exit is reachable from every other node (which is guaranteed by the problem statement).</p>
            
            <p>This is because:</p>
            <ol>
                <li>The transition matrix of the random walk is irreducible (can reach exit from anywhere)</li>
                <li>The exit is an absorbing state</li>
                <li>The expected hitting time to an absorbing state from any transient state is finite and well-defined</li>
            </ol>
        </div>

        <div class="section">
            <h2>COMPLEXITY ANALYSIS</h2>
            
            <h3>Time Complexity:</h3>
            <ul>
                <li>Building adjacency list: O(M)</li>
                <li>Setting up matrix A: O(N² + M) since we iterate through each node and its neighbors</li>
                <li>Solving linear system: O(N³) using standard methods like LU decomposition</li>
                <li><strong>Overall: O(N³ + M)</strong></li>
            </ul>

            <h3>Space Complexity:</h3>
            <ul>
                <li>Adjacency list: O(N + M)</li>
                <li>Matrix A: O(N²)</li>
                <li><strong>Overall: O(N² + M)</strong></li>
            </ul>

            <p>Given the constraint N ≤ 20, this is very efficient and runs in milliseconds.</p>
        </div>

        <div class="section">
            <h2>ALTERNATIVE APPROACHES</h2>
            <ol>
                <li><strong>Gaussian Elimination by Hand:</strong><br>
                    Implement manual Gaussian elimination instead of using numpy.linalg.solve. Same complexity but more code.</li>
                
                <li><strong>Iterative Methods:</strong><br>
                    Use iterative solvers like Gauss-Seidel or Jacobi iteration. These can be faster for sparse matrices but require more implementation effort.</li>
                
                <li><strong>Simulation (Monte Carlo):</strong><br>
                    Run many random walks and average the results. This gives an approximate answer but is much slower and doesn't guarantee the required precision.</li>
                
                <li><strong>Dynamic Programming with Memoization:</strong><br>
                    Not directly applicable since this is not a DAG - cycles make pure DP infeasible without solving a system of equations.</li>
            </ol>
        </div>

        <div class="section">
            <h2>VERIFICATION WITH SAMPLE OUTPUTS</h2>
            <table>
                <tr>
                    <th>Sample</th>
                    <th>N, M</th>
                    <th>Expected</th>
                    <th>Output</th>
                    <th>Status</th>
                </tr>
                <tr>
                    <td>Sample 1</td>
                    <td>N=3, M=3</td>
                    <td>2.000000</td>
                    <td>2.000000</td>
                    <td class="checkmark">✓</td>
                </tr>
                <tr>
                    <td>Sample 2</td>
                    <td>N=5, M=6</td>
                    <td>6.727273</td>
                    <td>6.727273</td>
                    <td class="checkmark">✓</td>
                </tr>
                <tr>
                    <td>Sample 3</td>
                    <td>N=4, M=4</td>
                    <td>3.333333</td>
                    <td>3.333333</td>
                    <td class="checkmark">✓</td>
                </tr>
            </table>
            <p>All test cases pass with the required precision (error &lt; 10<sup>-5</sup>).</p>
        </div>

        <div class="section">
            <h2>KEY INSIGHTS</h2>
            <ol>
                <li>This problem cannot be solved greedily - we must consider all possible random paths simultaneously through expected value.</li>
                
                <li>The key transformation is recognizing that the recursive definition of expected values creates a linear system that can be solved efficiently.</li>
                
                <li>The problem is well-posed because the graph structure guarantees that the exit is reachable (given in problem statement) and the exit is an absorbing state (degree check in code handles this).</li>
                
                <li>Using numpy's numerical solver is much cleaner than implementing custom matrix solving code and is sufficiently accurate for the problem's precision requirements.</li>
            </ol>
        </div>
    </div>
</body>
</html>